// API Configuration
const API_BASE_URL = 'https://malollas.pythonanywhere.com/api'; 

// --- APP LOGIC ---
const App = {
    state: { 
        maxLvl: 1, 
        lives: 3, 
        timers: [], 
        lang: 'ru', 
        sound: true, 
        vib: true, 
        savedLevels: {},
        tgUserId: null,
        tgUsername: null,
        tgFirstName: null,
        tgLastName: null,
        tgConnected: false,
        coins: 0,
        skins: ['default'],
        selectedSkin: 'default'
    },
    curNum: 1,
    boardSize: 5,
    // ... остальные свойства остаются без изменений ...

    init() {
        console.log('App initializing...');
        
        // Пробуем загрузить из Telegram Cloud Storage
        this.initTelegramCloudStorage().then(() => {
            console.log('Telegram Cloud Storage initialized');
        }).catch(() => {
            console.log('Telegram Cloud Storage not available, using localStorage');
            this.loadFromLocalStorage();
        });
        
        this.initTelegramWebApp();
        this.updateUI();
        Confetti.init();
        setInterval(() => this.tick(), 1000);
        
        // Initialize audio context
        const unlock = () => {
            if(!this.audioCtx) {
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio context not supported');
                }
            }
            if(this.audioCtx && this.audioCtx.state === 'suspended') {
                this.audioCtx.resume();
            }
            window.removeEventListener('touchstart', unlock);
            window.removeEventListener('click', unlock);
        };
        window.addEventListener('touchstart', unlock);
        window.addEventListener('click', unlock);
        console.log('App initialized successfully');
    },

    // НОВЫЙ МЕТОД: Инициализация Telegram Cloud Storage
    async initTelegramCloudStorage() {
        if (window.Telegram?.WebApp?.CloudStorage) {
            try {
                // Получаем все сохраненные данные
                const keys = await window.Telegram.WebApp.CloudStorage.getKeys();
                console.log('Telegram Cloud Storage keys:', keys);
                
                if (keys && keys.length > 0) {
                    // Загружаем основное состояние
                    const stateData = await window.Telegram.WebApp.CloudStorage.getItem('game_state');
                    if (stateData) {
                        const saved = JSON.parse(stateData);
                        this.state = { ...this.state, ...saved };
                        console.log('Loaded from Telegram Cloud Storage:', saved);
                    }
                }
                return true;
            } catch (error) {
                console.error('Error accessing Telegram Cloud Storage:', error);
                throw error;
            }
        } else {
            console.log('Telegram Cloud Storage not available');
            throw new Error('Telegram Cloud Storage not available');
        }
    },

    // Загрузка из localStorage (fallback)
    loadFromLocalStorage() {
        try {
            const d = localStorage.getItem('arrows_pro_v19');
            if (d) {
                const saved = JSON.parse(d);
                this.state = {...this.state, ...saved};
                console.log('Loaded from localStorage:', saved);
            }
        } catch (e) {
            console.error('Error loading from localStorage:', e);
        }
    },

    // ОБНОВЛЕННЫЙ МЕТОД: Сохранение состояния
    async save() {
        try {
            // Сохраняем в Telegram Cloud Storage если доступно
            if (window.Telegram?.WebApp?.CloudStorage) {
                await window.Telegram.WebApp.CloudStorage.setItem('game_state', JSON.stringify(this.state));
                console.log('Saved to Telegram Cloud Storage');
            }
            
            // Также сохраняем в localStorage для совместимости
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem('arrows_pro_v19', JSON.stringify(this.state));
            }
        } catch (error) {
            console.error('Error saving data:', error);
            
            // Fallback на localStorage
            try {
                if (typeof localStorage !== 'undefined') {
                    localStorage.setItem('arrows_pro_v19', JSON.stringify(this.state));
                }
            } catch (e) {
                console.error('Error saving to localStorage:', e);
            }
        }
    },

    // ОБНОВЛЕННЫЙ МЕТОД: Принудительная перегенерация первого уровня
    loadLvl(n) {
        console.log(`Loading level ${n}, isTelegram: ${!!window.Telegram?.WebApp}`);
        
        const b = document.getElementById('board');
        if (!b) return;
        b.innerHTML = '';
        this.boardSize = this.getBoardSizeForLevel(n);
        const boardContainer = document.querySelector('.board-zone');
        if (!boardContainer) return;
        
        // Принудительный рефлоу
        void boardContainer.offsetWidth;
        
        let containerWidth = Math.min(boardContainer.offsetWidth, boardContainer.offsetHeight);
        if (containerWidth === 0) {
            containerWidth = Math.min(window.innerWidth, window.innerHeight) - 40;
        }

        const boardPixelSize = Math.min(containerWidth - 40, 400);
        
        b.style.width = boardPixelSize + 'px';
        b.style.height = boardPixelSize + 'px';
        
        this.addGridLines(b, boardPixelSize);
        const cellSize = boardPixelSize / this.boardSize;
        const arrowSize = Math.min(cellSize * 0.85, this.getArrowSizeForLevel(n, this.boardSize));
        
        // КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Всегда перегенерируем первый уровень в Telegram
        // Это предотвращает проблему с кэшированными данными
        if (n === 1) {
            console.log('Regenerating level 1 (forced for Telegram compatibility)');
            this.state.savedLevels[1] = this.generate(1, this.boardSize);
        } else if (!this.state.savedLevels[n]) {
            this.state.savedLevels[n] = this.generate(n, this.boardSize);
        }
        
        const data = this.state.savedLevels[n];
        console.log(`Level ${n} has ${data.length} arrows, solved: ${data.filter(a => a.solved).length}`);
        
        // ВАЖНО: Сбрасываем состояние solved для отрисовки
        if (n === 1) {
            data.forEach(a => a.solved = false);
        }
        
        let arrowsCreated = 0;
        data.forEach(a => {
            if(a.solved) {
                console.log(`Arrow ${a.id} is solved, skipping`);
                return;
            }
            
            // Создаем контейнер для стрелки
            const arrowContainer = document.createElement('div');
            arrowContainer.className = 'arrow-container';
            arrowContainer.style.width = arrowSize + 'px';
            arrowContainer.style.height = arrowSize + 'px';
            arrowContainer.style.left = (a.x * cellSize + (cellSize - arrowSize) / 2) + 'px';
            arrowContainer.style.top = (a.y * cellSize + (cellSize - arrowSize) / 2) + 'px';
            
            // Добавляем класс направления
            let directionClass = '';
            switch(a.dir) {
                case 'R': directionClass = 'arrow-right'; break;
                case 'L': directionClass = 'arrow-left'; break;
                case 'U': directionClass = 'arrow-up'; break;
                case 'D': directionClass = 'arrow-down'; break;
            }
            arrowContainer.classList.add(directionClass);
            
            // Создаем тело стрелки
            const arrowBody = document.createElement('div');
            arrowBody.className = 'arrow-body';
            
            // Создаем голову стрелки
            const arrowHead = document.createElement('div');
            arrowHead.className = 'arrow-head';
            
            // Добавляем элементы в контейнер
            arrowContainer.appendChild(arrowBody);
            arrowContainer.appendChild(arrowHead);
            
            // Сохраняем ссылки
            a.element = arrowContainer;
            a.bodyElement = arrowBody;
            a.headElement = arrowHead;
            
            // Обработчик клика
            arrowContainer.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.move(a, arrowSize);
            });
            
            arrowContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.move(a, arrowSize);
            }, {passive: false});
            
            b.appendChild(arrowContainer);
            arrowsCreated++;
        });
        
        console.log(`Created ${arrowsCreated} arrow containers for level ${n}`);
        
        // Принудительный reflow и проверка
        void b.offsetWidth;
        
        // Дополнительная проверка через 100ms
        setTimeout(() => {
            const arrows = document.querySelectorAll('.arrow-container');
            console.log(`Confirmed ${arrows.length} arrows rendered for level ${n}`);
            
            // Если стрелок нет, пробуем экстренную перегенерацию
            if (arrows.length === 0 && n === 1) {
                console.warn('No arrows rendered! Attempting emergency fix...');
                this.emergencyRegenerateLevel1();
            }
        }, 100);
    },

    // НОВЫЙ МЕТОД: Экстренная перегенерация первого уровня
    emergencyRegenerateLevel1() {
        console.log('Emergency regeneration of level 1');
        
        // Полностью очищаем кэш для уровня 1
        delete this.state.savedLevels[1];
        
        // Принудительно устанавливаем прогресс на начало
        this.state.maxLvl = 1;
        this.state.lives = 3;
        this.state.coins = 0;
        
        // Сохраняем
        this.save();
        
        // Перезагружаем уровень
        setTimeout(() => {
            this.loadLvl(1);
        }, 200);
    },

    // ... остальные методы остаются без изменений ...

    // ОБНОВЛЕННЫЙ МЕТОД: Показ победы
    showWin() {
        const coinsEarned = 20;
        this.state.coins += coinsEarned;
        if(this.curNum === this.state.maxLvl) this.state.maxLvl++;
        this.save(); // Сохраняем прогресс
        
        // ... остальной код без изменений ...
    },

    // НОВЫЙ МЕТОД: Сброс прогресса
    resetProgress() {
        if (confirm('Are you sure you want to reset all progress? This cannot be undone.')) {
            // Полностью сбрасываем состояние
            this.state = {
                maxLvl: 1,
                lives: 3,
                timers: [],
                lang: 'ru',
                sound: true,
                vib: true,
                savedLevels: {},
                tgUserId: this.state.tgUserId,
                tgUsername: this.state.tgUsername,
                tgFirstName: this.state.tgFirstName,
                tgLastName: this.state.tgLastName,
                tgConnected: this.state.tgConnected,
                coins: 0,
                skins: ['default'],
                selectedSkin: 'default'
            };
            
            // Очищаем хранилища
            this.clearAllStorage();
            
            // Обновляем UI
            this.updateUI();
            this.nav('home');
            
            alert('Progress has been reset!');
        }
    },

    // НОВЫЙ МЕТОД: Очистка всех хранилищ
    async clearAllStorage() {
        try {
            // Очищаем Telegram Cloud Storage
            if (window.Telegram?.WebApp?.CloudStorage) {
                const keys = await window.Telegram.WebApp.CloudStorage.getKeys();
                for (const key of keys) {
                    await window.Telegram.WebApp.CloudStorage.removeItem(key);
                }
            }
            
            // Очищаем localStorage
            if (typeof localStorage !== 'undefined') {
                localStorage.removeItem('arrows_pro_v19');
            }
        } catch (error) {
            console.error('Error clearing storage:', error);
        }
    }
};

// Инициализация с улучшенной обработкой Telegram
window.onload = function() {
    console.log('Page loaded, starting game...');
    
    // Проверяем, в Telegram ли мы
    const isTelegram = !!window.Telegram?.WebApp;
    console.log('Is Telegram environment:', isTelegram);
    
    try {
        // Небольшая задержка для инициализации Telegram WebApp
        setTimeout(() => {
            App.init();
            console.log('Game started successfully!');
            
            // Для отладки: добавляем кнопку сброса прогресса
            if (isTelegram) {
                const homeScreen = document.getElementById('scr-home');
                if (homeScreen) {
                    const resetBtn = document.createElement('button');
                    resetBtn.textContent = 'Reset Progress';
                    resetBtn.style.cssText = 'padding:8px 15px; background:#ff4d4d; color:white; border:none; border-radius:8px; font-weight:bold; margin-top:10px;';
                    resetBtn.onclick = () => App.resetProgress();
                    homeScreen.appendChild(resetBtn);
                }
            }
        }, 100);
    } catch (error) {
        console.error('Error starting game:', error);
        const app = document.getElementById('app');
        if (app) {
            app.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <h1 style="color: var(--c-red);">Error Loading Game</h1>
                    <p>${error.message}</p>
                    <button onclick="location.reload()" style="padding:10px 20px; background:var(--c-blue); color:white; border:none; border-radius:10px; margin-top:20px;">Reload</button>
                </div>
            `;
        }
    }
};

// Telegram-специфичные фиксы
if (window.Telegram?.WebApp) {
    console.log('Telegram WebApp detected, applying fixes');
    
    // Гарантируем, что Telegram WebApp инициализирован
    window.Telegram.WebApp.ready();
    window.Telegram.WebApp.expand();
    
    // Принудительный reflow при изменении ориентации
    window.addEventListener('orientationchange', function() {
        console.log('Orientation changed, reloading level');
        setTimeout(() => {
            if (App.curNum) {
                App.loadLvl(App.curNum);
            }
        }, 300);
    });
    
    // Мониторинг видимости страницы
    document.addEventListener('visibilitychange', function() {
        console.log('Visibility changed:', document.visibilityState);
        if (document.visibilityState === 'visible' && App.curNum === 1) {
            // При возвращении на видимую страницу перезагружаем уровень 1
            setTimeout(() => {
                App.loadLvl(1);
            }, 200);
        }
    });
}
